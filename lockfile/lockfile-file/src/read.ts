import path from 'node:path'
import { promises as fs } from 'node:fs'

import yaml from 'js-yaml'
import semver from 'semver'
import stripBom from 'strip-bom'
import comverToSemver from 'comver-to-semver'

import { PnpmError } from '@pnpm/error'
import { LOCKFILE_VERSION, WANTED_LOCKFILE } from '@pnpm/constants'
import { mergeLockfileChanges } from '@pnpm/merge-lockfile-changes'
import { DEPENDENCIES_FIELDS, type Lockfile, type ProjectSnapshot, type LockfileFile } from '@pnpm/types'

import { lockfileLogger } from './logger.js'
import { getWantedLockfileName } from './lockfileName.js'
import { LockfileBreakingChangeError } from './errors/index.js'
import { autofixMergeConflicts, isDiff } from './gitMergeFile.js'
import { getGitBranchLockfileNames } from './gitBranchLockfile.js'
import { revertFromInlineSpecifiersFormatIfNecessary } from './experiments/inlineSpecifiersLockfileConverters.js'

export async function readCurrentLockfile(
  virtualStoreDir: string,
  opts: {
    wantedVersions?: string[] | undefined
    ignoreIncompatible: boolean
  }
): Promise<Lockfile | null> {
  const lockfilePath = path.join(virtualStoreDir, 'lock.yaml')

  return (await _read(lockfilePath, virtualStoreDir, opts)).lockfile
}

export async function readWantedLockfileAndAutofixConflicts(
  pkgPath: string,
  opts: {
    wantedVersions?: string[] | undefined
    ignoreIncompatible: boolean
    useGitBranchLockfile?: boolean | undefined
    mergeGitBranchLockfiles?: boolean | undefined
  }
): Promise<{
    lockfile: Lockfile | null
    hadConflicts: boolean
  }> {
  return _readWantedLockfile(pkgPath, {
    ...opts,
    autofixMergeConflicts: true,
  })
}

export async function readWantedLockfile(
  pkgPath: string,
  opts: {
    wantedVersions?: string[] | undefined
    ignoreIncompatible: boolean
    useGitBranchLockfile?: boolean | undefined
    mergeGitBranchLockfiles?: boolean | undefined
  }
): Promise<Lockfile | null> {
  return (await _readWantedLockfile(pkgPath, opts)).lockfile
}

async function _read(
  lockfilePath: string,
  prefix: string, // only for logging
  opts: {
    autofixMergeConflicts?: boolean | undefined
    wantedVersions?: string[] | undefined
    ignoreIncompatible: boolean
  }
): Promise<{
    lockfile: Lockfile | null
    hadConflicts: boolean
  }> {
  let lockfileRawContent

  try {
    lockfileRawContent = stripBom(await fs.readFile(lockfilePath, 'utf8'))
  } catch (err: unknown) {
    if ((err as NodeJS.ErrnoException).code !== 'ENOENT') {
      throw err
    }

    return {
      lockfile: null,
      hadConflicts: false,
    }
  }

  let lockfile: Lockfile

  let hadConflicts: boolean
  try {
    lockfile = revertFromInlineSpecifiersFormatIfNecessary(
      convertFromLockfileFileMutable(yaml.load(lockfileRawContent) as Lockfile)
    )

    hadConflicts = false
  } catch (err: unknown) {
    if (!opts.autofixMergeConflicts || !isDiff(lockfileRawContent)) {
      throw new PnpmError(
        'BROKEN_LOCKFILE',
        // @ts-ignore
        `The lockfile at "${lockfilePath}" is broken: ${err.message as string}`
      )
    }

    hadConflicts = true

    lockfile = convertFromLockfileFileMutable(
      autofixMergeConflicts(lockfileRawContent)
    )

    lockfileLogger.info({
      message: `Merge conflict detected in ${WANTED_LOCKFILE} and successfully merged`,
      prefix,
    })
  }

  if (lockfile) {
    const lockfileSemver = comverToSemver(
      (lockfile.lockfileVersion ?? 0).toString()
    )

    if (
      !opts.wantedVersions ||
      opts.wantedVersions.length === 0 ||
      opts.wantedVersions.some((wantedVersion: string): boolean => {
        if (
          semver.major(lockfileSemver) !==
          semver.major(comverToSemver(wantedVersion))
        ) {
          return false
        }

        if (
          lockfile.lockfileVersion !== '6.1' &&
          semver.gt(lockfileSemver, comverToSemver(wantedVersion))
        ) {
          lockfileLogger.warn({
            message:
              `Your ${WANTED_LOCKFILE} was generated by a newer version of pnpm. ` +
              `It is a compatible version but it might get downgraded to version ${wantedVersion}`,
            prefix,
          })
        }

        return true
      })
    ) {
      return { lockfile, hadConflicts }
    }
  }

  if (opts.ignoreIncompatible) {
    lockfileLogger.warn({
      message: `Ignoring not compatible lockfile at ${lockfilePath}`,
      prefix,
    })

    return { lockfile: null, hadConflicts: false }
  }

  throw new LockfileBreakingChangeError(lockfilePath)
}

export function createLockfileObject(
  importerIds: string[],
  opts: {
    lockfileVersion: number | string
    autoInstallPeers?: boolean | undefined
    excludeLinksFromLockfile: boolean
  }
) {
  const importers = importerIds.reduce(
    (acc: Record<string, ProjectSnapshot>, importerId: string): Record<string, ProjectSnapshot> => {
      acc[importerId] = {
        dependencies: {},
        specifiers: {},
      }

      return acc
    },
    {}
  )

  return {
    importers,
    lockfileVersion: opts.lockfileVersion || LOCKFILE_VERSION,
    settings: {
      autoInstallPeers: opts.autoInstallPeers,
      excludeLinksFromLockfile: opts.excludeLinksFromLockfile,
    },
  }
}

async function _readWantedLockfile(
  pkgPath: string,
  opts: {
    wantedVersions?: string[] | undefined
    ignoreIncompatible: boolean
    useGitBranchLockfile?: boolean | undefined
    mergeGitBranchLockfiles?: boolean | undefined
    autofixMergeConflicts?: boolean | undefined
  }
): Promise<{
    lockfile: Lockfile | null
    hadConflicts: boolean
  }> {
  const lockfileNames: string[] = [WANTED_LOCKFILE]

  if (opts.useGitBranchLockfile) {
    const gitBranchLockfileName: string = await getWantedLockfileName(opts)

    if (gitBranchLockfileName !== WANTED_LOCKFILE) {
      lockfileNames.unshift(gitBranchLockfileName)
    }
  }

  let result: { lockfile: Lockfile | null; hadConflicts: boolean } = {
    lockfile: null,
    hadConflicts: false,
  }

  for (const lockfileName of lockfileNames) {
    // eslint-disable-next-line no-await-in-loop
    result = await _read(path.join(pkgPath, lockfileName), pkgPath, {
      ...opts,
      autofixMergeConflicts: true,
    })

    if (result.lockfile) {
      if (opts.mergeGitBranchLockfiles) {
        // eslint-disable-next-line no-await-in-loop
        result.lockfile = await _mergeGitBranchLockfiles(
          result.lockfile,
          pkgPath,
          pkgPath,
          opts
        )
      }
      break
    }
  }

  return result
}

async function _mergeGitBranchLockfiles(
  lockfile: Lockfile | null,
  lockfileDir: string,
  prefix: string,
  opts: {
    autofixMergeConflicts?: boolean | undefined
    wantedVersions?: string[] | undefined
    ignoreIncompatible: boolean
  }
): Promise<Lockfile | null> {
  if (!lockfile) {
    return lockfile
  }

  const gitBranchLockfiles: Array<Lockfile | null> = (
    await _readGitBranchLockfiles(lockfileDir, prefix, opts)
  ).map(({ lockfile }: {
    lockfile: Lockfile | null;
    hadConflicts: boolean;
  }): Lockfile | null => {
    return lockfile;
  })

  let mergedLockfile: Lockfile = lockfile

  for (const gitBranchLockfile of gitBranchLockfiles) {
    if (!gitBranchLockfile) {
      continue
    }

    mergedLockfile = mergeLockfileChanges(mergedLockfile, gitBranchLockfile)
  }

  return mergedLockfile
}

async function _readGitBranchLockfiles(
  lockfileDir: string,
  prefix: string,
  opts: {
    autofixMergeConflicts?: boolean | undefined
    wantedVersions?: string[] | undefined
    ignoreIncompatible: boolean
  }
): Promise<
    Array<{
      lockfile: Lockfile | null
      hadConflicts: boolean
    }>
  > {
  const files = await getGitBranchLockfileNames(lockfileDir)

  return Promise.all(
    files.map((file: string): Promise<{
      lockfile: Lockfile | null;
      hadConflicts: boolean;
    }> => {
      return _read(path.join(lockfileDir, file), prefix, opts);
    })
  )
}

/**
 * Reverts changes from the "forceSharedFormat" write option if necessary.
 */
function convertFromLockfileFileMutable(lockfileFile: LockfileFile): Lockfile {
  if (typeof lockfileFile?.importers === 'undefined') {
    lockfileFile.importers = {
      '.': {
        specifiers: lockfileFile.specifiers ?? {},
        dependenciesMeta: lockfileFile.dependenciesMeta,
        publishDirectory: lockfileFile.publishDirectory,
      },
    }

    delete lockfileFile.specifiers

    for (const depType of DEPENDENCIES_FIELDS) {
      if (lockfileFile[depType] != null) {
        lockfileFile.importers['.'] = {
          specifiers: {},
          ...lockfileFile.importers['.'],
          [depType]: lockfileFile[depType],
        }

        delete lockfileFile[depType]
      }
    }
  }

  return lockfileFile as Lockfile
}
